<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ProTracker</title>
  <style>
    /* === Styles === */
    body { font-family: Arial, sans-serif; margin: 2rem; background: #fafbff; }
    .pattern-list { margin-bottom: 1rem; }
    .pattern { margin-bottom: 1.5rem; padding: 1rem; background: #fff; border-radius: 8px; box-shadow: 0 2px 6px #0001; }
    .dot-set { display: flex; gap: 0.5em; margin: 0.4em 0; }
    .dot-btn { width: 2em; height: 2em; border-radius: 50%; border: 1px solid #888; background: #eef; transition: background 0.2s, border 0.2s; cursor: pointer; position: relative; }
    .dot-btn[aria-pressed="true"] { background: #67e; border: 2px solid #24a; color: #fff; }
    .dot-btn:focus { outline: 2px solid #06f; }
    .pattern-title { font-weight: bold; margin-bottom: 0.3em; font-size: 1.1em; }
  </style>
</head>
<body>
  <h1>ProTracker</h1>
  <div id="pattern-list" class="pattern-list" aria-live="polite"></div>
  <button id="add-pattern-btn">Add Pattern</button>

<script>
// ==[ Namespace and Encapsulation ]==
window.app = (() => {
  // ==[ Configuration/Data Structures ]==
  const STORAGE_KEY = 'protracker_patterns';

  // ==[ Rendering Helpers ]==
  function renderDotButtons(dots) {
    return dots.map((on, i) => `
      <button class="dot-btn" type="button"
        data-dot-idx="${i}"
        aria-label="Toggle dot ${i+1}"
        aria-pressed="${on}"
        tabindex="0"
      >${on ? '●' : '○'}</button>
    `).join('');
  }

  function renderPattern(pattern, idx) {
    return `
      <div class="pattern" data-idx="${idx}" aria-label="Pattern ${idx+1}" tabindex="0">
        <div class="pattern-title">Pattern ${idx+1}</div>
        <div class="dot-set" role="group" aria-label="Set dots">${renderDotButtons(pattern.dots)}</div>
      </div>
    `;
  }

  // ==[ Storage Logic and Caching ]==
  let patternsCache = null;
  function getPatterns() {
    if (patternsCache !== null) return patternsCache;
    try {
      const saved = localStorage.getItem(STORAGE_KEY);
      patternsCache = saved ? JSON.parse(saved) : [];
    } catch {
      patternsCache = [];
    }
    return patternsCache;
  }
  function setPatterns(patterns) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(patterns));
    patternsCache = patterns;
  }

  // ==[ Rendering ]==
  function render() {
    const patterns = getPatterns();
    const patternList = document.getElementById('pattern-list');
    if (!patterns.length) {
      patternList.innerHTML = '<div>No patterns yet.</div>';
      return;
    }
    patternList.innerHTML = patterns.map(renderPattern).join('');
  }

  // ==[ Event Handlers ]==
  function handlePatternListClick(e) {
    // Event delegation for dot toggles
    const btn = e.target.closest('.dot-btn');
    if (!btn) return;
    const patternDiv = btn.closest('.pattern');
    const dotIdx = Number(btn.dataset.dotIdx);
    const patternIdx = Number(patternDiv.dataset.idx);

    const patterns = getPatterns().slice(); // shallow copy
    patterns[patternIdx].dots[dotIdx] = !patterns[patternIdx].dots[dotIdx];
    setPatterns(patterns);
    render();
    // Focus remains on recently toggled button
    setTimeout(() => {
      // Find the new button after re-render
      const newPatternDiv = document.querySelector(`.pattern[data-idx='${patternIdx}']`);
      if (newPatternDiv) {
        const btns = newPatternDiv.querySelectorAll('.dot-btn');
        if (btns[dotIdx]) btns[dotIdx].focus();
      }
    }, 0);
  }

  function handleAddPattern() {
    const patterns = getPatterns().slice();
    patterns.push({ dots: [false, false, false, false] });
    setPatterns(patterns);
    render();
  }

  // ==[ Initialization ]==
  function init() {
    document.getElementById('pattern-list').addEventListener('click', handlePatternListClick);
    document.getElementById('add-pattern-btn').addEventListener('click', handleAddPattern);
    render();
  }

  // Auto-init
  window.addEventListener('DOMContentLoaded', init);

  // ==[ Exports (if needed in future) ]==
  return {
    render,
    getPatterns,
    setPatterns
  };
})();
</script>
</body>
</html>
